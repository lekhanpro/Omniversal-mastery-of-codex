<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Knowledge Map - Omniversal Codex</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Raleway:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Raleway', sans-serif;
      background: #030508;
      color: #fff;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      cursor: grab;
    }

    #canvas.dragging {
      cursor: grabbing;
    }

    .ui-panel {
      position: fixed;
      background: rgba(5, 10, 25, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(201, 168, 76, 0.25);
      border-radius: 8px;
      padding: 16px;
      z-index: 10;
      font-family: 'Raleway', sans-serif;
    }

    #header {
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }

    #header h1 {
      font-family: 'Cinzel', serif;
      font-size: 24px;
      margin-bottom: 4px;
      color: #c9a84c;
    }

    #header p {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }

    #back-btn {
      position: fixed;
      top: 16px;
      left: 16px;
      background: rgba(5, 10, 25, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(201, 168, 76, 0.25);
      border-radius: 6px;
      padding: 10px 20px;
      color: #c9a84c;
      font-family: 'Raleway', sans-serif;
      font-size: 14px;
      cursor: pointer;
      z-index: 10;
      display: none;
      transition: all 0.3s;
    }

    #back-btn:hover {
      background: rgba(201, 168, 76, 0.15);
      border-color: #c9a84c;
    }

    #search-container {
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      max-width: 90vw;
    }

    #search-input {
      width: 100%;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(201, 168, 76, 0.3);
      border-radius: 6px;
      padding: 10px 16px;
      color: #fff;
      font-family: 'Raleway', sans-serif;
      font-size: 14px;
      outline: none;
    }

    #search-input:focus {
      border-color: #c9a84c;
    }

    #search-results {
      margin-top: 8px;
      font-size: 12px;
      color: #c9a84c;
      text-align: center;
    }

    #heat-toggle {
      position: fixed;
      top: 16px;
      right: 16px;
      background: rgba(5, 10, 25, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(201, 168, 76, 0.25);
      border-radius: 6px;
      padding: 10px 20px;
      color: #fff;
      font-family: 'Raleway', sans-serif;
      font-size: 14px;
      cursor: pointer;
      z-index: 10;
      transition: all 0.3s;
    }

    #heat-toggle:hover {
      background: rgba(201, 168, 76, 0.15);
      border-color: #c9a84c;
    }

    #heat-toggle.active {
      background: rgba(201, 168, 76, 0.25);
      border-color: #c9a84c;
      color: #c9a84c;
    }

    #stats-panel {
      bottom: 16px;
      left: 16px;
      min-width: 200px;
    }

    #stats-panel h3 {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: #c9a84c;
      margin-bottom: 12px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 12px;
    }

    .stat-label {
      color: rgba(255, 255, 255, 0.6);
    }

    .stat-value {
      color: #c9a84c;
      font-weight: 600;
    }

    #tooltip {
      position: fixed;
      background: rgba(5, 10, 25, 0.95);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(201, 168, 76, 0.4);
      border-radius: 6px;
      padding: 12px 16px;
      z-index: 20;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      max-width: 300px;
    }

    #tooltip.visible {
      opacity: 1;
    }

    #tooltip h4 {
      font-family: 'Cinzel', serif;
      font-size: 14px;
      color: #c9a84c;
      margin-bottom: 6px;
    }

    #tooltip p {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.4;
    }

    #legend {
      position: fixed;
      bottom: 16px;
      right: 16px;
      background: rgba(5, 10, 25, 0.85);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(201, 168, 76, 0.25);
      border-radius: 6px;
      padding: 12px;
      z-index: 10;
      display: none;
    }

    #legend.visible {
      display: block;
    }

    #legend h4 {
      font-family: 'Cinzel', serif;
      font-size: 12px;
      color: #c9a84c;
      margin-bottom: 8px;
    }

    .legend-gradient {
      width: 200px;
      height: 20px;
      background: linear-gradient(to right, #1a3a6a, #c9a84c);
      border-radius: 4px;
      margin-bottom: 6px;
    }

    .legend-labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.6);
    }

    @media (max-width: 768px) {
      #search-container {
        width: calc(100vw - 32px);
      }
      
      #stats-panel {
        font-size: 11px;
        min-width: 160px;
      }
      
      #heat-toggle {
        font-size: 12px;
        padding: 8px 16px;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <button id="back-btn">← All Domains</button>
  
  <div id="search-container" class="ui-panel">
    <input type="text" id="search-input" placeholder="Search domains and subjects...">
    <div id="search-results"></div>
  </div>
  
  <button id="heat-toggle">Mastery Heat Map</button>
  
  <div id="stats-panel" class="ui-panel">
    <h3>NEURAL STATS</h3>
    <div class="stat-row">
      <span class="stat-label">Nodes:</span>
      <span class="stat-value" id="stat-nodes">0</span>
    </div>

    <div class="stat-row">
      <span class="stat-label">Connections:</span>
      <span class="stat-value" id="stat-connections">0</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Most Connected:</span>
      <span class="stat-value" id="stat-hub">-</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Hovered:</span>
      <span class="stat-value" id="stat-hovered">-</span>
    </div>
  </div>
  
  <div id="legend">
    <h4>Mastery Level</h4>
    <div class="legend-gradient"></div>
    <div class="legend-labels">
      <span>0% Cold</span>
      <span>100% Hot</span>
    </div>
  </div>
  
  <div id="tooltip">
    <h4 id="tooltip-title"></h4>
    <p id="tooltip-desc"></p>
  </div>

  <script>
    // ========== CONFIGURATION ==========
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    
    const cx = width / 2;
    const cy = height / 2;
    
    // Mastery data (editable percentages)
    const masteryData = {
      1: 65, 2: 80, 3: 55, 4: 40, 5: 70,
      6: 45, 7: 60, 8: 50, 9: 75, 10: 85
    };
    
    // Domain definitions
    const domains = [
      { id: 1, name: 'Mathematics', color: '#4488ff', subjects: 16 },
      { id: 2, name: 'Computer Science', color: '#00ffcc', subjects: 16 },

      { id: 3, name: 'AI & Machine Learning', color: '#aa44ff', subjects: 16 },
      { id: 4, name: 'Physics & Engineering', color: '#ff6644', subjects: 16 },
      { id: 5, name: 'Philosophy', color: '#ffcc44', subjects: 16 },
      { id: 6, name: 'Economics & Finance', color: '#44ff88', subjects: 16 },
      { id: 7, name: 'Language & Communication', color: '#ff44aa', subjects: 16 },
      { id: 8, name: 'Biology & Life Sciences', color: '#88ff44', subjects: 16 },
      { id: 9, name: 'Psychology', color: '#ff8844', subjects: 16 },
      { id: 10, name: 'Strategy & Systems', color: '#44aaff', subjects: 16 }
    ];
    
    // Connection definitions
    const connections = [
      [1, 2], [1, 3], [1, 4], [1, 6],
      [2, 3], [2, 6], [2, 10],
      [3, 8], [3, 9], [3, 5],
      [4, 1], [4, 8],
      [5, 9], [5, 7], [5, 10],
      [6, 9], [6, 10],
      [7, 8], [7, 9],
      [8, 9], [8, 3]
    ];
    
    // ========== STATE ==========
    let nodes = [];
    let moons = [];
    let lines = [];
    let expandedDomain = null;
    let heatMapMode = false;
    let searchQuery = '';
    
    let offsetX = 0, offsetY = 0;
    let scale = 1;
    let isDragging = false;
    let dragStartX = 0, dragStartY = 0;
    let dragStartOffsetX = 0, dragStartOffsetY = 0;
    
    let hoveredNode = null;
    let time = 0;
    let introProgress = 0;
    let isIntroComplete = false;
    
    // ========== INITIALIZATION ==========
    function init() {
      // Create domain nodes
      domains.forEach((domain, i) => {
        const angle = (i / domains.length) * Math.PI * 2 - Math.PI / 2;
        const radius = Math.min(width, height) * 0.3;

        
        nodes.push({
          id: domain.id,
          name: domain.name,
          type: 'domain',
          color: domain.color,
          x: cx,
          y: cy,
          targetX: cx + Math.cos(angle) * radius,
          targetY: cy + Math.sin(angle) * radius,
          vx: 0,
          vy: 0,
          fx: 0,
          fy: 0,
          radius: 28,
          scale: 0,
          targetScale: 1,
          opacity: 1,
          pulseOffset: Math.random() * Math.PI * 2,
          pulseSpeed: 0.8 + Math.random() * 0.4,
          subjects: domain.subjects
        });
      });
      
      // Create connection lines
      connections.forEach(([from, to]) => {
        lines.push({
          from: from - 1,
          to: to - 1,
          t: Math.random(),
          speed: 0.004,
          opacity: 0.15,
          targetOpacity: 0.15
        });
      });
      
      // Pre-settle physics
      for (let i = 0; i < 50; i++) {
        updatePhysics(0.016);
      }
      
      // Set initial positions to settled positions
      nodes.forEach(node => {
        node.targetX = node.x;
        node.targetY = node.y;
      });
      
      updateStats();
      animate();
    }
    
    // ========== PHYSICS ==========
    function updatePhysics(dt) {
      const k = 8000;
      const attractionStrength = 0.002;
      const damping = 0.88;
      const centeringForce = 0.0003;
      
      // Reset forces
      nodes.forEach(node => {
        node.fx = 0;
        node.fy = 0;
      });

      
      // Repulsion between all nodes
      for (let i = 0; i < nodes.length; i++) {
        for (let j = i + 1; j < nodes.length; j++) {
          const dx = nodes[j].x - nodes[i].x;
          const dy = nodes[j].y - nodes[i].y;
          const dist = Math.sqrt(dx * dx + dy * dy) || 1;
          const force = k / (dist * dist);
          
          nodes[i].fx -= (dx / dist) * force;
          nodes[i].fy -= (dy / dist) * force;
          nodes[j].fx += (dx / dist) * force;
          nodes[j].fy += (dy / dist) * force;
        }
      }
      
      // Attraction along connections
      lines.forEach(line => {
        const n1 = nodes[line.from];
        const n2 = nodes[line.to];
        const dx = n2.x - n1.x;
        const dy = n2.y - n1.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const force = dist * attractionStrength;
        
        n1.fx += dx * force;
        n1.fy += dy * force;
        n2.fx -= dx * force;
        n2.fy -= dy * force;
      });
      
      // Centering force
      nodes.forEach(node => {
        node.fx += (cx - node.x) * centeringForce;
        node.fy += (cy - node.y) * centeringForce;
      });
      
      // Apply forces and damping
      nodes.forEach(node => {
        node.vx = (node.vx + node.fx * dt) * damping;
        node.vy = (node.vy + node.fy * dt) * damping;
        
        // Add tiny random drift
        node.vx += (Math.random() - 0.5) * 0.04;
        node.vy += (Math.random() - 0.5) * 0.04;
        
        node.x += node.vx;
        node.y += node.vy;
      });
    }
    
    // ========== RENDERING ==========
    function render() {
      ctx.clearRect(0, 0, width, height);

      
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(scale, scale);
      
      // Draw intro shockwave
      if (introProgress > 0 && introProgress < 1) {
        const shockRadius = introProgress * Math.max(width, height);
        const shockOpacity = (1 - introProgress) * 0.3;
        ctx.strokeStyle = `rgba(201, 168, 76, ${shockOpacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, shockRadius, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      // Draw connection lines
      lines.forEach((line, i) => {
        const n1 = nodes[line.from];
        const n2 = nodes[line.to];
        
        if (!n1 || !n2) return;
        
        const opacity = line.opacity * n1.opacity * n2.opacity;
        
        // Base line
        ctx.strokeStyle = `rgba(201, 168, 76, ${opacity})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y);
        ctx.lineTo(n2.x, n2.y);
        ctx.stroke();
        
        // Traveling dot
        const dotX = n1.x + (n2.x - n1.x) * line.t;
        const dotY = n1.y + (n2.y - n1.y) * line.t;
        const dotSize = line.opacity > 0.5 ? 4 : 2;
        
        ctx.fillStyle = `rgba(201, 168, 76, ${Math.min(opacity * 2, 1)})`;
        ctx.beginPath();
        ctx.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Update traveling dot
        line.t += line.speed;
        if (line.t > 1) line.t = 0;
      });
      
      // Draw moons
      moons.forEach(moon => {
        if (moon.opacity < 0.01) return;
        
        ctx.save();
        ctx.globalAlpha = moon.opacity;

        
        // Calculate orbit position
        const angle = moon.angle + time * moon.speed;
        const x = moon.parentX + Math.cos(angle) * moon.orbitRadius;
        const y = moon.parentY + Math.sin(angle) * moon.orbitRadius;
        
        // Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = moon.color;
        
        // Moon circle
        ctx.fillStyle = moon.color;
        ctx.beginPath();
        ctx.arc(x, y, moon.radius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      });
      
      // Draw domain nodes
      nodes.forEach(node => {
        if (node.opacity < 0.01) return;
        
        ctx.save();
        ctx.globalAlpha = node.opacity;
        
        const displayScale = node.scale * (hoveredNode === node ? 1.4 : 1);
        const currentRadius = node.radius * displayScale;
        
        // Get color (heat map or normal)
        let nodeColor = node.color;
        if (heatMapMode) {
          const mastery = masteryData[node.id] || 0;
          nodeColor = interpolateColor('#1a3a6a', '#c9a84c', mastery / 100);
        }
        
        // Pulse glow
        const pulseSize = 20 + Math.sin(time * 0.001 * node.pulseSpeed + node.pulseOffset) * 12;
        ctx.shadowBlur = pulseSize;
        ctx.shadowColor = nodeColor;
        
        // Draw orbit rings
        if (!expandedDomain) {
          ctx.strokeStyle = `${nodeColor}33`;
          ctx.lineWidth = 1;
          ctx.setLineDash([4, 4]);
          
          ctx.beginPath();
          ctx.arc(node.x, node.y, currentRadius + 15, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.arc(node.x, node.y, currentRadius + 25, 0, Math.PI * 2);
          ctx.stroke();
          
          ctx.setLineDash([]);
        }

        
        // Planet circle
        ctx.fillStyle = nodeColor;
        ctx.beginPath();
        ctx.arc(node.x, node.y, currentRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
        // Label
        ctx.fillStyle = '#fff';
        ctx.font = '12px Cinzel';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(node.name, node.x, node.y + currentRadius + 8);
        
        ctx.restore();
      });
      
      ctx.restore();
    }
    
    // ========== ANIMATION LOOP ==========
    function animate() {
      time++;
      
      // Intro animation
      if (!isIntroComplete) {
        introProgress += 0.016 / 1.5;
        if (introProgress >= 1) {
          introProgress = 1;
          isIntroComplete = true;
        }
        
        const t = easeOutElastic(introProgress);
        nodes.forEach(node => {
          node.x = cx + (node.targetX - cx) * t;
          node.y = cy + (node.targetY - cy) * t;
          node.scale = t;
        });
      } else {
        // Normal physics
        if (!expandedDomain) {
          updatePhysics(0.016);
        }
        
        // Smooth scale transitions
        nodes.forEach(node => {
          node.scale += (node.targetScale - node.scale) * 0.08;
        });
        
        // Smooth line opacity transitions
        lines.forEach(line => {
          line.opacity += (line.targetOpacity - line.opacity) * 0.08;
        });
      }
      
      // Update moon positions
      moons.forEach(moon => {
        const parent = nodes.find(n => n.id === moon.parentId);
        if (parent) {
          moon.parentX = parent.x;
          moon.parentY = parent.y;
        }
      });

      
      render();
      requestAnimationFrame(animate);
    }
    
    // ========== EASING FUNCTIONS ==========
    function easeOutElastic(t) {
      const c4 = (2 * Math.PI) / 3;
      return t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * c4) + 1;
    }
    
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    
    function interpolateColor(color1, color2, t) {
      const r1 = parseInt(color1.slice(1, 3), 16);
      const g1 = parseInt(color1.slice(3, 5), 16);
      const b1 = parseInt(color1.slice(5, 7), 16);
      
      const r2 = parseInt(color2.slice(1, 3), 16);
      const g2 = parseInt(color2.slice(3, 5), 16);
      const b2 = parseInt(color2.slice(5, 7), 16);
      
      const r = Math.round(r1 + (r2 - r1) * t);
      const g = Math.round(g1 + (g2 - g1) * t);
      const b = Math.round(b1 + (b2 - b1) * t);
      
      return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }
    
    // ========== INTERACTION ==========
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.clientX - rect.left - offsetX) / scale,
        y: (e.clientY - rect.top - offsetY) / scale
      };
    }
    
    function getTouchPos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: (e.touches[0].clientX - rect.left - offsetX) / scale,
        y: (e.touches[0].clientY - rect.top - offsetY) / scale
      };
    }
    
    function findNodeAtPos(x, y) {
      for (let i = nodes.length - 1; i >= 0; i--) {
        const node = nodes[i];
        const dx = x - node.x;
        const dy = y - node.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < node.radius * node.scale) {
          return node;
        }
      }
      return null;
    }
    
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        offsetX = dragStartOffsetX + (e.clientX - dragStartX);
        offsetY = dragStartOffsetY + (e.clientY - dragStartY);
        return;
      }
      
      const pos = getMousePos(e);
      const node = findNodeAtPos(pos.x, pos.y);
      
      if (node !== hoveredNode) {
        hoveredNode = node;
        
        if (node) {
          // Show tooltip
          const tooltip = document.getElementById('tooltip');
          const tooltipTitle = document.getElementById('tooltip-title');
          const tooltipDesc = document.getElementById('tooltip-desc');
          
          tooltipTitle.textContent = node.name;
          tooltipDesc.textContent = `${node.subjects} subjects • Domain ${node.id}`;
          
          tooltip.style.left = e.clientX + 20 + 'px';
          tooltip.style.top = e.clientY + 20 + 'px';
          tooltip.classList.add('visible');
          
          // Update stats
          document.getElementById('stat-hovered').textContent = node.name;
          
          // Highlight connections
          lines.forEach(line => {
            if (nodes[line.from] === node || nodes[line.to] === node) {
              line.targetOpacity = 0.8;
              line.speed = 0.008;
            } else {
              line.targetOpacity = 0.15;
              line.speed = 0.004;
            }
          });
          
          // Fade unconnected nodes
          nodes.forEach(n => {
            if (n === node) return;
            const isConnected = lines.some(line => 
              (nodes[line.from] === node && nodes[line.to] === n) ||
              (nodes[line.to] === node && nodes[line.from] === n)
            );
            n.opacity = isConnected ? 1 : 0.15;
          });
        } else {
          // Hide tooltip
          document.getElementById('tooltip').classList.remove('visible');
          document.getElementById('stat-hovered').textContent = '-';

          
          // Reset all
          lines.forEach(line => {
            line.targetOpacity = 0.15;
            line.speed = 0.004;
          });
          nodes.forEach(n => n.opacity = 1);
        }
      }
    });
    
    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);
      const node = findNodeAtPos(pos.x, pos.y);
      
      if (node) {
        expandDomain(node);
      } else {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartOffsetX = offsetX;
        dragStartOffsetY = offsetY;
        canvas.classList.add('dragging');
      }
    });
    
    canvas.addEventListener('mouseup', () => {
      isDragging = false;
      canvas.classList.remove('dragging');
    });
    
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newScale = Math.max(0.4, Math.min(3, scale * delta));
      
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
      offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);
      
      scale = newScale;
    });
    
    // ========== DOMAIN EXPANSION ==========
    function expandDomain(node) {
      if (expandedDomain === node.id) return;
      
      expandedDomain = node.id;
      document.getElementById('back-btn').style.display = 'block';
      
      // Move clicked node to center
      node.targetX = cx;
      node.targetY = cy;
      node.targetScale = 1.5;

      
      // Push other nodes outward
      nodes.forEach(n => {
        if (n === node) return;
        const angle = Math.atan2(n.y - cy, n.x - cx);
        const dist = Math.max(width, height) * 0.6;
        n.targetX = cx + Math.cos(angle) * dist;
        n.targetY = cy + Math.sin(angle) * dist;
        n.targetScale = 0.7;
      });
      
      // Animate node movement
      const moveInterval = setInterval(() => {
        nodes.forEach(n => {
          n.x += (n.targetX - n.x) * 0.12;
          n.y += (n.targetY - n.y) * 0.12;
        });
      }, 16);
      
      setTimeout(() => clearInterval(moveInterval), 600);
      
      // Spawn moons
      moons = [];
      for (let i = 0; i < node.subjects; i++) {
        const angle = (i / node.subjects) * Math.PI * 2;
        const orbitRadius = 60 + (i % 3) * 30;
        
        setTimeout(() => {
          moons.push({
            id: `${node.id}-${i}`,
            parentId: node.id,
            parentX: node.x,
            parentY: node.y,
            angle: angle,
            orbitRadius: orbitRadius,
            speed: 0.0005 + Math.random() * 0.0003,
            radius: 8,
            color: lightenColor(node.color, 0.4),
            opacity: 0
          });
          
          // Fade in
          const moon = moons[moons.length - 1];
          let fadeProgress = 0;
          const fadeInterval = setInterval(() => {
            fadeProgress += 0.05;
            moon.opacity = Math.min(1, fadeProgress);
            if (fadeProgress >= 1) clearInterval(fadeInterval);
          }, 16);
        }, i * 50);
      }
    }
    
    function collapseDomain() {
      expandedDomain = null;
      document.getElementById('back-btn').style.display = 'none';
      
      // Reset all nodes
      nodes.forEach((node, i) => {
        const angle = (i / nodes.length) * Math.PI * 2 - Math.PI / 2;
        const radius = Math.min(width, height) * 0.3;
        node.targetX = cx + Math.cos(angle) * radius;
        node.targetY = cy + Math.sin(angle) * radius;
        node.targetScale = 1;
      });

      
      // Fade out moons
      moons.forEach(moon => {
        let fadeProgress = 1;
        const fadeInterval = setInterval(() => {
          fadeProgress -= 0.05;
          moon.opacity = Math.max(0, fadeProgress);
          if (fadeProgress <= 0) {
            clearInterval(fadeInterval);
            moons = moons.filter(m => m !== moon);
          }
        }, 16);
      });
      
      // Animate node movement
      const moveInterval = setInterval(() => {
        nodes.forEach(n => {
          n.x += (n.targetX - n.x) * 0.12;
          n.y += (n.targetY - n.y) * 0.12;
        });
      }, 16);
      
      setTimeout(() => clearInterval(moveInterval), 600);
    }
    
    document.getElementById('back-btn').addEventListener('click', collapseDomain);
    
    // ========== SEARCH ==========
    const searchInput = document.getElementById('search-input');
    const searchResults = document.getElementById('search-results');
    
    searchInput.addEventListener('input', (e) => {
      searchQuery = e.target.value.toLowerCase();
      
      if (!searchQuery) {
        nodes.forEach(n => n.opacity = 1);
        searchResults.textContent = '';
        return;
      }
      
      let matchCount = 0;
      let domainCount = 0;
      
      nodes.forEach(node => {
        if (node.name.toLowerCase().includes(searchQuery)) {
          node.opacity = 1;
          matchCount++;
          domainCount++;
          
          // Pulse effect
          ctx.shadowBlur = 40;
        } else {
          node.opacity = 0.05;
        }
      });
      
      searchResults.textContent = `${matchCount} domains found`;
    });
    
    searchInput.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        searchInput.value = '';
        searchQuery = '';
        nodes.forEach(n => n.opacity = 1);
        searchResults.textContent = '';
      }
    });

    
    // ========== HEAT MAP TOGGLE ==========
    const heatToggle = document.getElementById('heat-toggle');
    const legend = document.getElementById('legend');
    
    heatToggle.addEventListener('click', () => {
      heatMapMode = !heatMapMode;
      heatToggle.classList.toggle('active');
      legend.classList.toggle('visible');
      
      // Adjust node sizes based on mastery
      if (heatMapMode) {
        nodes.forEach(node => {
          const mastery = masteryData[node.id] || 0;
          node.radius = 28 + (mastery / 100) * 8;
        });
      } else {
        nodes.forEach(node => {
          node.radius = 28;
        });
      }
    });
    
    // ========== STATS UPDATE ==========
    function updateStats() {
      document.getElementById('stat-nodes').textContent = nodes.length + moons.length;
      document.getElementById('stat-connections').textContent = lines.length;
      
      // Find most connected domain
      const connectionCounts = {};
      lines.forEach(line => {
        const id1 = nodes[line.from]?.id;
        const id2 = nodes[line.to]?.id;
        connectionCounts[id1] = (connectionCounts[id1] || 0) + 1;
        connectionCounts[id2] = (connectionCounts[id2] || 0) + 1;
      });
      
      let maxConnections = 0;
      let mostConnected = null;
      Object.entries(connectionCounts).forEach(([id, count]) => {
        if (count > maxConnections) {
          maxConnections = count;
          mostConnected = nodes.find(n => n.id === parseInt(id));
        }
      });
      
      if (mostConnected) {
        document.getElementById('stat-hub').textContent = mostConnected.name;
      }
    }
    
    setInterval(updateStats, 1000);
    
    // ========== UTILITY FUNCTIONS ==========
    function lightenColor(color, amount) {
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      
      const newR = Math.min(255, Math.round(r + (255 - r) * amount));
      const newG = Math.min(255, Math.round(g + (255 - g) * amount));
      const newB = Math.min(255, Math.round(b + (255 - b) * amount));

      
      return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
    }
    
    // ========== RESIZE HANDLER ==========
    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });
    
    // ========== START ==========
    init();
  </script>
</body>
</html>
